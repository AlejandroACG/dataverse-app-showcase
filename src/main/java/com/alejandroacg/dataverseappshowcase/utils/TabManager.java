package com.alejandroacg.dataverseappshowcase.utils;

import com.alejandroacg.dataverseappshowcase.controllers.SearchController;
import com.alejandroacg.dataverseappshowcase.controllers.details.DetailsController;
import com.alejandroacg.dataverseappshowcase.search.SearchHandler;
import com.alejandroacg.dataverseappshowcase.search.SearchHandlerFactory;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import lombok.Getter;
import lombok.Setter;

import java.io.IOException;

/**
 * Centralized manager responsible for handling all dynamic tabs within the application UI.
 * <p>
 * Responsibilities include:
 * <ul>
 *     <li>Opening and restoring Search tabs</li>
 *     <li>Opening and restoring Details tabs</li>
 *     <li>Ensuring only one tab per unique logical target exists</li>
 *     <li>Associating tabs with their controllers for later refresh or update</li>
 *     <li>Rebuilding tabs after application-wide refresh operations</li>
 * </ul>
 * <p>
 * Each tab is uniquely identified through an ID generated by {@link KeyBuilder}.
 */
public class TabManager {

    // TODO Only the currently selected Tab can be closed by clicking the wheel.

    /** Singleton instance made available through explicit setter (injected from MainController). */
    @Getter
    @Setter
    private static TabManager instance;

    /** The root TabPane managed by this class. */
    private final TabPane tabPane;

    public TabManager(TabPane tabPane) {
        this.tabPane = tabPane;
    }

    // --------------------------------------------------------------------------------------------
    //  SEARCH TAB MANAGEMENT
    // --------------------------------------------------------------------------------------------

    /**
     * Opens a Search tab for the given entity type.
     * <p>
     * Behaviour:
     * <ul>
     *     <li>If the tab already exists, it is focused.</li>
     *     <li>All other search tabs are removed, ensuring only one Search tab is open at once.</li>
     *     <li>Loads the Search FXML, initializes its controller, and displays it.</li>
     * </ul>
     */
    public void openSearchTab(EntityType type) {
        String tabId = KeyBuilder.searchTabKey(type);

        // If already open, simply focus it
        if (checkExistingTab(tabId, true)) return;

        // Remove other search tabs to keep the interface clean and type-specific
        tabPane.getTabs().removeIf(
                tab -> tab.getId() != null
                        && tab.getId().startsWith("search_") && !tab.getId().endsWith(type.getPluralLowerCase())
        );

        try {
            FXMLLoader loader = new FXMLLoader(TabManager.class.getResource(KeyBuilder.searchFXMLPath()));
            Parent root = loader.load();

            SearchController controller = loader.getController();
            SearchHandler handler = SearchHandlerFactory.getHandler(type);
            controller.setEntityType(type);
            controller.setSearchHandler(handler);

            createAndAddTab(type.getPlural(), tabId, root, true, controller, true);

        } catch (IllegalArgumentException e) {
            // No handler registered for the type
            AlertManager.handle(type.getSingular(), null, null, ManualErrorType.MISSING_HANDLER);

        } catch (IOException e) {
            GlobalExceptionHandler.handle(e);
        }
    }

    // --------------------------------------------------------------------------------------------
    //  DETAILS TAB MANAGEMENT
    // --------------------------------------------------------------------------------------------

    /**
     * Opens a Details tab for a given entity instance.
     * <p>
     * Behaviour:
     * <ul>
     *     <li>If the Details tab already exists, it is focused.</li>
     *     <li>Loads the appropriate Details FXML file based on entity type.</li>
     *     <li>Injects the entity ID into the DetailsController so it can load its data asynchronously.</li>
     * </ul>
     */
    public void openDetailsTab(EntityType type, Long entityId, String tabName, boolean giveFocus) {
        String tabId = KeyBuilder.detailsTabKey(type, entityId);

        if (checkExistingTab(tabId, giveFocus)) return;

        try {
            FXMLLoader loader = new FXMLLoader(TabManager.class.getResource(KeyBuilder.detailsFXMLPath(type)));
            Parent root = loader.load();
            DetailsController controller = loader.getController();

            controller.setEntityId(entityId);

            createAndAddTab(tabName, tabId, root, false, controller, giveFocus);
        } catch (IllegalArgumentException e) {
            AlertManager.handle(type.getSingular(), null, null, ManualErrorType.MISSING_HANDLER);
        } catch (IOException e) {
            GlobalExceptionHandler.handle(e);
        }
    }

    // --------------------------------------------------------------------------------------------
    //  CONTROLLER ACCESS
    // --------------------------------------------------------------------------------------------

    /**
     * Retrieves the controller associated with a specific tab ID, if present.
     * This allows other parts of the application to send updates or refresh signals to tabs.
     */
    public <T> T getControllerForTab(String tabId, Class<T> controllerClass) {
        for (Tab tab : tabPane.getTabs()) {
            if (tabId.equals(tab.getId())) {
                Object data = tab.getUserData();
                if (controllerClass.isInstance(data)) {
                    return controllerClass.cast(data);
                }
            }
        }
        return null;
    }

    // --------------------------------------------------------------------------------------------
    //  REFRESH LOGIC
    // --------------------------------------------------------------------------------------------

    /**
     * Refreshes only the Search tab for the given entity type.
     * <p>
     * Used typically after operations that alter data affecting the search results (e.g., creation or deletion).
     */
    public void refreshSearchTab(EntityType type) {
        String tabId = KeyBuilder.searchTabKey(type);
        for (int i = 0; i < tabPane.getTabs().size(); i++) {
            Tab tab = tabPane.getTabs().get(i);
            if (tabId.equals(tab.getId())) {
                tabPane.getTabs().remove(i);
                openSearchTab(type);
                break;
            }
        }
    }

    // --------------------------------------------------------------------------------------------
    //  INTERNAL HELPER METHODS
    // --------------------------------------------------------------------------------------------

    /**
     * Checks whether a tab with the specified ID already exists.
     * Optionally brings it to focus.
     *
     * @return true if the tab was found, false otherwise
     */
    private boolean checkExistingTab(String tabId, boolean giveFocus) {
        for (Tab existingTab : tabPane.getTabs()) {
            if (tabId.equals(existingTab.getId())) {
                if (giveFocus) {
                    tabPane.getSelectionModel().select(existingTab);
                }
                return true;
            }
        }
        return false;
    }

    /**
     * Internal helper for creating and adding a new tab to the TabPane.
     * Handles insertion order, controller assignment, and initial focus.
     */
    private void createAndAddTab(
            String title, String tabId, Parent root, boolean addFirst, Object controller, boolean giveFocus) {
        Tab tab = new Tab(title);
        tab.setId(tabId);
        tab.setContent(root);

        if (controller != null) {
            tab.setUserData(controller);
        }

        if (addFirst) {
            tabPane.getTabs().addFirst(tab);
        } else {
            tabPane.getTabs().add(tab);
        }

        if (giveFocus) {
            tabPane.getSelectionModel().select(tab);
        }
    }

    /**
     * Closes whichever tab is associated with the provided controller instance.
     * Used primarily by Details views needing to close themselves after deletion.
     */
    public void closeTabByController(Object controller) {
        for (Tab tab : tabPane.getTabs()) {
            if (tab.getUserData() == controller) {
                tabPane.getTabs().remove(tab);
                return;
            }
        }
    }
}
